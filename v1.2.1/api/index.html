<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public API · RedClust.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://abhinavnatarajan.github.io/RedClust.jl/api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">RedClust.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../generated/example/">Example</a></li><li class="is-active"><a class="tocitem" href>Public API</a><ul class="internal"><li><a class="tocitem" href="#Main-functions"><span>Main functions</span></a></li><li><a class="tocitem" href="#Point-estimation"><span>Point estimation</span></a></li><li><a class="tocitem" href="#Summary-and-clustering-evaluation"><span>Summary and clustering evaluation</span></a></li><li><a class="tocitem" href="#Convenience-functions"><span>Convenience functions</span></a></li><li><a class="tocitem" href="#Example-datasets"><span>Example datasets</span></a></li><li><a class="tocitem" href="#Types"><span>Types</span></a></li></ul></li><li><a class="tocitem" href="../changelog/">Changelog</a></li><li><a class="tocitem" href="../cite/">Cite This Package</a></li><li><a class="tocitem" href="../funding/">Funding Information</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Public API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/abhinavnatarajan/RedClust.jl/blob/master/docs/src/api.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Public-API"><a class="docs-heading-anchor" href="#Public-API">Public API</a><a id="Public-API-1"></a><a class="docs-heading-anchor-permalink" href="#Public-API" title="Permalink"></a></h1><h2 id="Main-functions"><a class="docs-heading-anchor" href="#Main-functions">Main functions</a><a id="Main-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Main-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RedClust.fitprior" href="#RedClust.fitprior"><code>RedClust.fitprior</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fitprior(data, algo, diss = false; 
Kmin = 1, 
Kmax = Int(floor(size(data)[end] / 2), 
verbose = true)</code></pre><p>Determines the best prior hyperparameters from the data. A notional clustering is obtained using k-means or k-medoids and the elbow method, and the distances are split into within-cluster distances and inter-cluster distances based on the notional clustering. These distances are then used to fit the prior hyperparameters using MLE and empirical Bayes sampling.   </p><p><strong>Required Arguments</strong></p><ul><li><code>data::Union{Vector{Vector{Float64}}, Matrix{Float64}}</code>: can either be a vector of (possibly multi-dimensional) observations, or a matrix with each column an observation, or a square matrix of pairwise dissimilarities. </li><li><code>algo::String</code>: must be one of <code>&quot;k-means&quot;</code> or <code>&quot;k-medoids&quot;</code>.</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>diss::bool</code>: if true, <code>data</code> will be assumed to be a pairwise dissimilarity matrix. </li><li><code>Kmin::Integer</code>: minimum number of clusters to scan for the elbow method.  </li><li><code>Kmax::Integer</code>: maximum number of clusters to scan for the elbow method. If left unspecified, it is set to half the number of observations.</li><li><code>verbose::Bool</code>: if false, disables all info messages and progress bars. </li></ul><p><strong>Returns</strong></p><p>An object of type <a href="#RedClust.PriorHyperparamsList"><code>PriorHyperparamsList</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/abhinavnatarajan/RedClust.jl/blob/8225e0f6ad8562718a6ca8abec22136efd6656ca/src/prior.jl#L8-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RedClust.fitprior2" href="#RedClust.fitprior2"><code>RedClust.fitprior2</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fitprior2(data, algo, diss = false; 
Kmin = 1, 
Kmax = Int(floor(size(data)[end] / 2), 
verbose = true)</code></pre><p>Determines the best prior hyperparameters from the data. Uses the same method as <a href="#RedClust.fitprior"><code>fitprior</code></a> to obtain values for <span>$\sigma$</span>, <span>$\eta$</span>, <span>$u$</span>, and <span>$v$</span>, but derives values for the cluster-specific parameters by considering within-cluster and cross-cluster distances over clusterings with <span>$K$</span> clusters for all values of <span>$K \in [K_\mathrm{min}, K_\mathrm{max}]$</span>, weighted by the prior predictive distribution of <span>$K$</span> in that range.   </p><p><strong>Required Arguments</strong></p><ul><li><code>data::Union{Vector{Vector{Float64}}, Matrix{Float64}}</code>: can either be a vector of (possibly multi-dimensional) observations, or a matrix with each column an observation, or a square matrix of pairwise dissimilarities. </li><li><code>algo::String</code>: must be one of <code>&quot;k-means&quot;</code> or <code>&quot;k-medoids&quot;</code>.</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>diss::bool</code>: if true, <code>data</code> will be assumed to be a pairwise dissimilarity matrix. </li><li><code>Kmin::Integer</code>: minimum number of clusters to scan for the elbow method.  </li><li><code>Kmax::Integer</code>: maximum number of clusters to scan for the elbow method. If left unspecified, it is set to half the number of observations.</li><li><code>verbose::Bool</code>: if false, disables all info messages and progress bars. </li></ul><p><strong>Returns</strong></p><p>An object of type <a href="#RedClust.PriorHyperparamsList"><code>PriorHyperparamsList</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/abhinavnatarajan/RedClust.jl/blob/8225e0f6ad8562718a6ca8abec22136efd6656ca/src/prior.jl#L137-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RedClust.sampleK-Tuple{Real, Real, Real, Real, Int64, Int64}" href="#RedClust.sampleK-Tuple{Real, Real, Real, Real, Int64, Int64}"><code>RedClust.sampleK</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sampleK(params::PriorHyperparamsList, numsamples::Int, n::Int)::Vector{Int}
sampleK(η::Real, σ::Real, u::Real, v::Real, numsamples::Int, n::Int)</code></pre><p>Returns a vector of length <code>numsamples</code> containing samples of <span>$K$</span> (number of clusters) generated from its marginal prior predictive distribution inferred from <code>params</code>. The parameter <code>n</code> is the number of observations in the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/abhinavnatarajan/RedClust.jl/blob/8225e0f6ad8562718a6ca8abec22136efd6656ca/src/prior.jl#L317-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RedClust.sampledist" href="#RedClust.sampledist"><code>RedClust.sampledist</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sampledist(params::PriorHyperparamsList, type::String, numsamples = 1)::Vector{Float64}</code></pre><p>Generate a vector of samples of length <code>numsamples</code> from the prior predictive distribution on the distances, as encapsulated in <code>params</code>. <code>type</code> must be either <code>&quot;intercluster&quot;</code> or <code>&quot;intracluster&quot;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/abhinavnatarajan/RedClust.jl/blob/8225e0f6ad8562718a6ca8abec22136efd6656ca/src/prior.jl#L286-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RedClust.runsampler" href="#RedClust.runsampler"><code>RedClust.runsampler</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">runsampler(data, 
options = MCMCOptionsList(), 
params = PriorHyperparamsList(); 
verbose = true) -&gt; MCMCResult</code></pre><p>Runs the MCMC sampler on the data.</p><p><strong>Arguments</strong></p><ul><li><code>data::MCMCData</code>: contains the distance matrix. </li><li><code>options::MCMCOptionsList</code>: contains the number of iterations, burnin, etc. </li><li><code>params::PriorHyperparamsList</code>: contains the prior hyperparameters for the model.</li><li><code>verbose::Bool</code>: if false, disables all info messages and progress bars. </li></ul><p><strong>Returns</strong></p><p>A struct of type <code>MCMCResult</code> containing the MCMC samples, convergence diagnostics, and summary statistics.</p><p><strong>See also</strong></p><p><a href="#RedClust.MCMCData"><code>MCMCData</code></a>, <a href="#RedClust.MCMCOptionsList"><code>MCMCOptionsList</code></a>, <a href="#RedClust.fitprior"><code>fitprior</code></a>, <a href="#RedClust.PriorHyperparamsList"><code>PriorHyperparamsList</code></a>, <a href="#RedClust.MCMCResult"><code>MCMCResult</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/abhinavnatarajan/RedClust.jl/blob/8225e0f6ad8562718a6ca8abec22136efd6656ca/src/mcmc.jl#L491-L510">source</a></section></article><h2 id="Point-estimation"><a class="docs-heading-anchor" href="#Point-estimation">Point estimation</a><a id="Point-estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Point-estimation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RedClust.binderloss-Tuple{Vector{Int64}, Vector{Int64}}" href="#RedClust.binderloss-Tuple{Vector{Int64}, Vector{Int64}}"><code>RedClust.binderloss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">binderloss(a::ClustLabelVector, b::ClustLabelVector;
normalised = true) -&gt; Float64</code></pre><p>Computes the Binder loss between two clusterings. If <code>normalised = true</code> then the result is equal to one minus the rand index between <code>a</code> and <code>b</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/abhinavnatarajan/RedClust.jl/blob/8225e0f6ad8562718a6ca8abec22136efd6656ca/src/pointestimate.jl#L65-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RedClust.getpointestimate-Tuple{MCMCResult}" href="#RedClust.getpointestimate-Tuple{MCMCResult}"><code>RedClust.getpointestimate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getpointestimate(samples::MCMCResult; method = &quot;MAP&quot;, loss = &quot;VI&quot;)</code></pre><p>Computes a point estimate from a vector of samples of cluster allocations by searching for a minimiser of the posterior expectation of some loss function. </p><p><strong>Arguments</strong></p><ul><li><code>method::String</code>: must be one of the following -<ul><li><code>&quot;MAP&quot;</code>: maximum a posteriori.</li><li><code>&quot;MLE&quot;</code>: maximum likelihood estimation.</li><li><code>&quot;MPEL&quot;</code>: minimum posterior expected loss.</li></ul><code>&quot;MAP&quot;</code> and <code>&quot;MLE&quot;</code> search among the MCMC samples for the clustering with the maximum log posterior and log likelihood respectively. <code>&quot;MPEL&quot;</code> searches for a clustering that minimises the posterior expected loss of some loss function specified by the <code>loss</code> argument. The search space is the set of samples in <code>samples</code>. </li><li><code>loss</code>: Determines the loss function used for the <code>&quot;MPEL&quot;</code> method. Must be either be a string or a function. If specified as a string, must be one of <code>&quot;binder&quot;</code> (Binder loss), <code>&quot;omARI&quot;</code> (one minus the Adjusted Rand Index), <code>&quot;VI&quot;</code> (Variation of Information distance), or <code>&quot;ID&quot;</code> (Information Distance). If specified as a function, must have a method defined for <code>(x::Vector{Int}, y::Vector{Int}) -&gt; Real</code>. </li></ul><p><strong>Returns</strong></p><p>Returns a tuple <code>(clust, i)</code> where <code>clust</code> is a clustering allocation in <code>samples</code> and <code>i</code> is its sample index. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/abhinavnatarajan/RedClust.jl/blob/8225e0f6ad8562718a6ca8abec22136efd6656ca/src/pointestimate.jl#L4-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RedClust.infodist-Tuple{Vector{Int64}, Vector{Int64}}" href="#RedClust.infodist-Tuple{Vector{Int64}, Vector{Int64}}"><code>RedClust.infodist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">infodist(a::ClustLabelVector, b::ClustLabelVector;
normalised = true) -&gt; Float64</code></pre><p>Computes the information distance between two clusterings. The information distance is defined as </p><p class="math-container">\[d_{\mathrm{ID}}(a, b) = \max \{H(A), H(B)\} - I(A, B)\]</p><p>where <span>$A$</span> and <span>$B$</span> are the cluster membership probability functions for <span>$a$</span> and <span>$b$</span> respectively, <span>$H$</span> denotes the entropy of a distribution, and <span>$I$</span> denotes the mutual information between two distributions. The information distance has range <span>$[0, \log N]$</span> where <span>$N$</span> is the number of observations. If normalised = true, the result is scaled to the range <span>$[0, 1]$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/abhinavnatarajan/RedClust.jl/blob/8225e0f6ad8562718a6ca8abec22136efd6656ca/src/pointestimate.jl#L81-L90">source</a></section></article><h2 id="Summary-and-clustering-evaluation"><a class="docs-heading-anchor" href="#Summary-and-clustering-evaluation">Summary and clustering evaluation</a><a id="Summary-and-clustering-evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Summary-and-clustering-evaluation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RedClust.evaluateclustering-Tuple{Vector{Int64}, Vector{Int64}}" href="#RedClust.evaluateclustering-Tuple{Vector{Int64}, Vector{Int64}}"><code>RedClust.evaluateclustering</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evaluateclustering(clusts::ClustLabelVector, truth::ClustLabelVector)</code></pre><p>Returns a named tuple of values quantifying the accuracy of the clustering assignments in <code>clusts</code> with respect to the ground truth clustering assignments in <code>truth</code>. </p><p><strong>Return values</strong></p><ul><li><code>nbloss</code>: Normalised Binder loss (= 1 - rand index). Lower is better. </li><li><code>ari</code>: Adjusted Rand index. Higher is better. </li><li><code>vi</code>: Variation of Information distance (<span>$\in [0, \log N]$</span>). Lower is better.</li><li><code>nvi</code>: Normalised VI distance (<span>$\in [0, 1]$</span>).</li><li><code>id</code>: Information Distance (<span>$\in [0, \log N]$</span>). Lower is better. </li><li><code>nid</code>: Normalised Information Distance (<span>$\in [0, 1]$</span>).</li><li><code>nmi</code>: Normalised Mutual Information (<span>$\in [0, 1]$</span>). Higher is better. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/abhinavnatarajan/RedClust.jl/blob/8225e0f6ad8562718a6ca8abec22136efd6656ca/src/summaries.jl#L3-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RedClust.summarise-Tuple{IO, Vector{Int64}, Vector{Int64}}" href="#RedClust.summarise-Tuple{IO, Vector{Int64}, Vector{Int64}}"><code>RedClust.summarise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">summarise([io::IO], clusts::ClustLabelVector, 
truth::ClustLabelVector, 
printoutput = true) -&gt; String</code></pre><p>Prints a summary of the clustering accuracy of <code>clusts</code> with respect to the ground truth in <code>truth</code>. The output is printed to the output stream <code>io</code>, which defaults to <code>stdout</code> if not provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/abhinavnatarajan/RedClust.jl/blob/8225e0f6ad8562718a6ca8abec22136efd6656ca/src/summaries.jl#L27-L32">source</a></section></article><h2 id="Convenience-functions"><a class="docs-heading-anchor" href="#Convenience-functions">Convenience functions</a><a id="Convenience-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Convenience-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RedClust.adjacencymatrix-Tuple{Vector{Int64}}" href="#RedClust.adjacencymatrix-Tuple{Vector{Int64}}"><code>RedClust.adjacencymatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">adjacencymatrix(clusts::ClustLabelVector) -&gt; Matrix{Bool}</code></pre><p>Returns the <code>n</code>×<code>n</code> adjacency matrix corresponding to the given cluster label vector <code>clusts</code>, where <code>n = length(clusts)</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/abhinavnatarajan/RedClust.jl/blob/8225e0f6ad8562718a6ca8abec22136efd6656ca/src/utils.jl#L63-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RedClust.generatemixture-Tuple{Integer, Integer}" href="#RedClust.generatemixture-Tuple{Integer, Integer}"><code>RedClust.generatemixture</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generatemixture(N, K; [α, dim, radius, σ, rng])</code></pre><p>Generates a multivariate Normal mixture, with kernel weights generated from a Dirichlet prior. The kernels are centred at the vertices of a <code>dim</code>-dimensional simplex with edge length <code>radius</code>.</p><p><strong>Required Arguments</strong></p><ul><li><code>N::Integer</code>: number of observations to generate.</li><li><code>K::Integer</code>: number of mixture kernels.</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>α::Float64 = K</code>: parameter for the Dirichlet prior.</li><li><code>dim::Integer = K</code>: dimension of the observations.</li><li><code>radius::Float64 = 1</code>: radius of the simplex whose vertices are the kernel means.</li><li><code>σ::Float64 = 0.1</code>: variance of each kernel.</li><li><code>rng</code>: a random number generator to use, or an integer to seed the default random number generator with. If not provided, the default RNG provided by the Random.jl package will be used with default seeding.</li></ul><p><strong>Returns</strong></p><p>Named tuple containing the following fields-</p><ul><li><code>points::Vector{Vector{Float64}}</code>: a vector of <code>N</code> observations.</li><li><code>distancematrix::Matrix{Float64}</code>: an <code>N</code>×<code>N</code> matrix of pairwise Euclidean distances between the observations.</li><li><code>clusts::ClustLabelVector</code>: vector of <code>N</code> cluster assignments.</li><li><code>probs::Float64</code>: vector of <code>K</code> cluster weights generated from the Dirichlet prior, used to generate the observations.</li><li><code>oracle_coclustering::Matrix{Float64}</code>: <code>N</code>×<code>N</code> matrix of co-clustering probabilities, calculated assuming full knowledge of the cluster centres and cluster weights.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/abhinavnatarajan/RedClust.jl/blob/8225e0f6ad8562718a6ca8abec22136efd6656ca/src/utils.jl#L84-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RedClust.makematrix-Tuple{AbstractVector{&lt;:AbstractVector}}" href="#RedClust.makematrix-Tuple{AbstractVector{&lt;:AbstractVector}}"><code>RedClust.makematrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">makematrix(x::AbstractVector{&lt;:AbstractVector}) -&gt; Matrix</code></pre><p>Convert a vector of vectors into a matrix, where each vector becomes a column in the matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/abhinavnatarajan/RedClust.jl/blob/8225e0f6ad8562718a6ca8abec22136efd6656ca/src/utils.jl#L157-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RedClust.sortlabels-Tuple{Vector{Int64}}" href="#RedClust.sortlabels-Tuple{Vector{Int64}}"><code>RedClust.sortlabels</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sortlabels(x::ClustLabelVector) -&gt; ClustLabelVector</code></pre><p>Returns a cluster label vector <code>y</code> such that <code>x</code> and <code>y</code> have the same adjacency structure and labels in <code>y</code> occur in sorted ascending order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/abhinavnatarajan/RedClust.jl/blob/8225e0f6ad8562718a6ca8abec22136efd6656ca/src/utils.jl#L73-L76">source</a></section></article><h2 id="Example-datasets"><a class="docs-heading-anchor" href="#Example-datasets">Example datasets</a><a id="Example-datasets-1"></a><a class="docs-heading-anchor-permalink" href="#Example-datasets" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RedClust.example_dataset-Tuple{Int64}" href="#RedClust.example_dataset-Tuple{Int64}"><code>RedClust.example_dataset</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">example_dataset(n::Int)</code></pre><p>Returns a named tuple containing the dataset from the n<span>$^{\mathrm{th}}$</span> simulated example in the main paper. This dataset was generated using the following code in Julia v1.8.1:</p><pre><code class="language-julia hljs">    using RedClust
    using Random: seed!
    seed!(44)
    K = 10 # Number of clusters 
    N = 100 # Number of points
    data_σ = [0.25, 0.2, 0.18][n] # Variance of the normal kernel
    data_dim = [10, 50, 10][n] # Data dimension
    data = generatemixture(N, K; α = 10, σ = data_σ, dim = data_dim);</code></pre><p>Note however that the above code may produce different results on your computer because the random number generator in Julia is not meant for reproducible results across different computers, different versions of Julia, or different versions of the Random.jl package, even with appropriate seeding. Therefore the datasets have been included with this package, and it is recommended to access them via this function.</p><p>See also <a href="#RedClust.generatemixture-Tuple{Integer, Integer}"><code>generatemixture</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/abhinavnatarajan/RedClust.jl/blob/8225e0f6ad8562718a6ca8abec22136efd6656ca/src/example_data.jl#L40-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RedClust.example_datasets-Tuple{}" href="#RedClust.example_datasets-Tuple{}"><code>RedClust.example_datasets</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a read-only handle to a HDF5 file that contains example datasets from the main paper. You must remember to close the file once you are done reading from it. This function is provided for reproducibility purposes only; it is recommended to read the datasets via the convenience function <a href="#RedClust.example_dataset-Tuple{Int64}"><code>example_dataset</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/abhinavnatarajan/RedClust.jl/blob/8225e0f6ad8562718a6ca8abec22136efd6656ca/src/example_data.jl#L33-L35">source</a></section></article><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RedClust.ClustLabelVector" href="#RedClust.ClustLabelVector"><code>RedClust.ClustLabelVector</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Alias for <code>Vector{Int}</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/abhinavnatarajan/RedClust.jl/blob/8225e0f6ad8562718a6ca8abec22136efd6656ca/src/types.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RedClust.MCMCData" href="#RedClust.MCMCData"><code>RedClust.MCMCData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MCMCData(points::AbstractVector{&lt;:AbstractVector{&lt;:Float64}})    
MCMCData(dissimilaritymatrix::AbstractMatrix{Float64})</code></pre><p>Contains the pairwise dissimilarities for the MCMC sampler.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/abhinavnatarajan/RedClust.jl/blob/8225e0f6ad8562718a6ca8abec22136efd6656ca/src/types.jl#L140-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RedClust.MCMCOptionsList" href="#RedClust.MCMCOptionsList"><code>RedClust.MCMCOptionsList</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MCMCOptionsList(; 
numiters = 5000, 
burnin = floor(0.2 * numiters), 
thin = 1, 
numGibbs = 5, 
numMH = 1)</code></pre><p>List of options for running the MCMC. </p><p><strong>Constructor arguments</strong></p><ul><li><code>numiters::Integer</code>: number of iterations to run.</li><li><code>burnin::Integer</code>: number of iterations to discard as burn-in.</li><li><code>thin::Integer</code>: will keep every <code>thin</code> samples.</li><li><code>numGibbs:Integer</code>: number of intermediate Gibbs scans in the split-merge step.</li><li><code>numMH:Integer</code>: number of split-merge steps per MCMC iteration.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/abhinavnatarajan/RedClust.jl/blob/8225e0f6ad8562718a6ca8abec22136efd6656ca/src/types.jl#L10-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RedClust.MCMCResult" href="#RedClust.MCMCResult"><code>RedClust.MCMCResult</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Struct containing MCMC samples. </p><p><strong>Fields</strong></p><ul><li><code>options::MCMCOptionsList</code>: options passed to the sampler. </li><li><code>params::PriorHyperparamsList</code>: prior hyperparameters used by the sampler. </li><li><code>clusts::Vector{ClustLabelVector}</code>: contains the clustering allocations. <code>clusts[i]</code> is a vector containing the clustering allocation from the <code>i</code>th sample. </li><li><code>posterior_coclustering::Matrix{Float64}</code>: the posterior coclustering matrix. </li><li><code>K::Vector{Int}</code>: posterior samples of <span>$K$</span>, i.e., the number of clusters. <code>K[i]</code> is the number of clusters in <code>clusts[i]</code>.</li><li><code>r::Vector{Float64}</code>: posterior samples of the parameter <span>$r$</span>.</li><li><code>p::Vector{Float64}</code>: posterior samples of the parameter <span>$p$</span>.</li><li><code>K_mean</code>, <code>r_mean</code>, <code>p_mean</code>: posterior mean of <code>K</code>, <code>r</code>, and <code>p</code> respectively. </li><li><code>K_variance</code>, <code>r_variance</code>, <code>p_variance</code>: posterior variance of <code>K</code>, <code>r</code>, and <code>p</code> respectively. </li><li><code>K_acf::Vector{Float64}</code>, <code>r_acf::Vector{Float64}</code>, <code>p_acf::Vector{Float64}</code>: autocorrelation function for <code>K</code>, <code>r</code>, and <code>p</code> respectively. </li><li><code>K_iac</code>, <code>r_iac</code>, and <code>p_iac</code>: integrated autocorrelation coefficient for <code>K</code>, <code>r</code>, and <code>p</code> respectively. </li><li><code>K_ess::Float64</code>, <code>r_ess::Float64</code>, and <code>p_ess::Float64</code>: effective sample size for <code>K</code>, <code>r</code>, and <code>p</code> respectively.</li><li><code>loglik::Vector{Float64}</code>: log-likelihood for each sample. </li><li><code>logposterior::Vector{Float64}</code>: a function proportional to the log-posterior for each sample, with constant of proportionality equal to the normalising constant of the partition prior.</li><li><code>splitmerge_splits</code>: Boolean vector indicating the iterations when a split proposal was used in the split-merge step. Has length <code>numMH * numiters</code> (see <a href="#RedClust.MCMCOptionsList"><code>MCMCOptionsList</code></a>).</li><li><code>splitmerge_acceptance_rate</code>: acceptance rate of the split-merge proposals. </li><li><code>r_acceptances</code>: Boolean vector indicating the iterations (including burnin and the thinned out iterations) where the Metropolis-Hastings proposal for <code>r</code> was accepted. </li><li><code>r_acceptance_rate:</code>: Metropolis-Hastings acceptance rate for <code>r</code>.</li><li><code>runtime</code>: total runtime for all iterations.</li><li><code>mean_iter_time</code>: average time taken for each iteration. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/abhinavnatarajan/RedClust.jl/blob/8225e0f6ad8562718a6ca8abec22136efd6656ca/src/types.jl#L170-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RedClust.PriorHyperparamsList" href="#RedClust.PriorHyperparamsList"><code>RedClust.PriorHyperparamsList</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PriorHyperparamsList(; [kwargs])</code></pre><p>Contains the prior hyperparameters for the model. It is recommended to set the values using the <a href="#RedClust.fitprior"><code>fitprior</code></a> function. Do not set these values manually unless you know what you are doing. </p><p><strong>Constructor arguments</strong></p><ul><li><code>δ1::Float64 = 1</code>: the parameter <span>$\delta_1$</span>.</li><li><code>α::Float64 = 1</code>: the shape parameter <span>$\alpha$</span> in the prior for each <span>$\lambda_k$</span>.</li><li><code>β::Float64 = 1</code>: the rate parameter <span>$\beta$</span> in the prior for each <span>$\lambda_k$</span>.</li><li><code>δ2::Float64 = 1</code>: the parameter <span>$\delta_2$</span>.</li><li><code>ζ::Float64 = 1</code>: the shape parameter <span>$\zeta$</span> in the prior for each <span>$\theta_{kt}$</span>.</li><li><code>γ::Float64 = 1</code>: the rate parameter <span>$\gamma$</span> in the prior for each <span>$\theta_{kt}$</span>.</li><li><code>η::Float64 = 1</code>: the shape parameter <span>$\eta$</span> in the prior for <span>$r$</span>.</li><li><code>σ::Float64 = 1</code>: the rate parameter <span>$\sigma$</span> in the prior for <span>$r$</span>.</li><li><code>u::Float64 = 1</code>: the parameter <span>$u$</span> in the prior for <span>$p$</span>.</li><li><code>v::Float64 = 1</code>: the parameter <span>$v$</span> in the prior for <span>$p$</span>.</li><li><code>proposalsd_r::Float64 = 1</code>: standard deviation of the truncated Normal proposal when sampling <code>r</code> via a Metropolis-Hastings step. </li><li><code>K_initial::Int = 1</code>: initial number of clusters to start the MCMC.</li><li><code>repulsion::Bool = true</code>: whether to use the repulsive component of the likelihood. </li><li><code>maxK::Int = 0</code>: maxmimum number of clusters to allow. If set to 0 then no maximum is imposed.</li></ul><p><strong>See also</strong></p><p><a href="#RedClust.fitprior"><code>fitprior</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/abhinavnatarajan/RedClust.jl/blob/8225e0f6ad8562718a6ca8abec22136efd6656ca/src/types.jl#L70-L93">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../generated/example/">« Example</a><a class="docs-footer-nextpage" href="../changelog/">Changelog »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 14 March 2023 14:47">Tuesday 14 March 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
